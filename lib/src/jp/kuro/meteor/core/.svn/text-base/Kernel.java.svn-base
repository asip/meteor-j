/**
 *XML解析パーサコア
 *
 */

package jp.kuro.meteor.core;

//JAVA標準

import jp.kuro.meteor.AttributeMap;
import jp.kuro.meteor.Element;
import jp.kuro.meteor.Parser;
import jp.kuro.meteor.RootElement;
import jp.kuro.meteor.core.util.AsyncStringBuffer;
import jp.kuro.meteor.core.util.PatternCache;
import jp.kuro.meteor.core.html.ParserImpl;
import jp.kuro.meteor.exception.NoSuchElementException;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public abstract class Kernel {
    // フックスケール
    private int hookScale = 2400;

    //ルート要素
    protected RootElement root = null;

    //親パーサ
    protected Parser parent;

    //正規表現用オブジェクト
    protected Pattern pattern = null;
    protected Matcher matcher = null;
    protected Matcher _matcher = null;

    //文字列バッファ
    protected AsyncStringBuffer sbuf = new AsyncStringBuffer();

    protected static final String EMPTY = "";
    protected static final String SPACE = " ";
    protected static final String DOUBLE_QUATATION = "\"";
    protected static final String TAG_OPEN = "<";
    protected static final String TAG_OPEN3 = "</";
    protected static final String TAG_OPEN4 = "<\\\\/";
    protected static final String TAG_CLOSE = ">";
    protected static final String TAG_CLOSE2 = "\\/>";
    protected static final String TAG_CLOSE3 = "/>";
    protected static final String ATTR_EQ = "=\"";
    //findElement
    //protected static final String TAG_SEARCH_1_1 = "([^<>]*)>(((?!(<\\/";
    protected static final String TAG_SEARCH_1_1 = "(\\s[^<>]*)>(((?!(";
    //protected static final String TAG_SEARCH_1_2 = "))[\\w\\W])*)<\\/";
    protected static final String TAG_SEARCH_1_2 = "[^<>]*>))[\\w\\W])*)<\\/";
    protected static final String TAG_SEARCH_1_3 = "(\\s[^<>]*)\\/>";
    //protected static final String TAG_SEARCH_1_4 = "([^<>\\/]*)>";
    protected static final String TAG_SEARCH_1_4 = "(\\s[^<>\\/]*>|((?!([^<>]*\\/>))[^<>]*>))";
    protected static final String TAG_SEARCH_1_4_2 = "(\\s[^<>]*)>";
    //protected static final String TAG_SEARCH_2_1 = "\\s([^<>]*";
    protected static final String TAG_SEARCH_2_1 = "(\\s[^<>]*";
    protected static final String TAG_SEARCH_2_1_2 = "(\\s[^<>]*(";
    //protected static final String TAG_SEARCH_2_2 = "\"[^<>]*)>(((?!(<\\/";
    protected static final String TAG_SEARCH_2_2 = "\"[^<>]*)>(((?!(";
    protected static final String TAG_SEARCH_2_2_2 = "\")[^<>]*)>(((?!(";
    protected static final String TAG_SEARCH_2_3 = "\"[^<>]*)";
    protected static final String TAG_SEARCH_2_3_2 = "\"[^<>]*)\\/>";
    protected static final String TAG_SEARCH_2_3_2_2 = "\")[^<>]*)\\/>";
    //protected static final String TAG_SEARCH_2_4 = "\"[^<>\\/]*>";
    protected static final String TAG_SEARCH_2_4 = "([^<>\\/]*>|((?!([^<>]*\\/>))[^<>]*>))";
    //protected static final String TAG_SEARCH_2_4_2 = "\"[^<>\\/]*)>";
    protected static final String TAG_SEARCH_2_4_2 = "([^<>\\/]*>|((?!([^<>]*\\/>))[^<>]*>)))";
    protected static final String TAG_SEARCH_2_4_2_2 = "\")([^<>\\/]*>|((?!([^<>]*\\/>))[^<>]*>)))";
    protected static final String TAG_SEARCH_2_4_3 = "\"[^<>]*)>";
    protected static final String TAG_SEARCH_2_4_3_2 = "\")[^<>]*)>";
    protected static final String TAG_SEARCH_2_4_4 = "\"[^<>]*>";

    protected static final String TAG_SEARCH_2_6 = "\"[^<>]*";
    protected static final String TAG_SEARCH_2_7 = "\"|";

    protected static final String TAG_SEARCH_3_1 = "<([^<>\"]*)\\s[^<>]*";
    protected static final String TAG_SEARCH_3_1_2 = "<([^<>\"]*)\\s([^<>]*";
    protected static final String TAG_SEARCH_3_1_2_2 = "<([^<>\"]*)\\s([^<>]*(";

    protected static final String TAG_SEARCH_3_2 = "\"[^<>]*\\/>";
    protected static final String TAG_SEARCH_3_2_2 = "\"[^<>]*)\\/>";
    protected static final String TAG_SEARCH_3_2_2_2 = "\")[^<>]*)\\/>";

    protected static final String TAG_SEARCH_4_1 = "([^<>\\/]*)>(";
    protected static final String TAG_SEARCH_4_2 = "[\\w\\W]*<";
    //protected static final String TAG_SEARCH_4_3 = "[^<>\\/]*>";
    protected static final String TAG_SEARCH_4_3 = "(\\s[^<>\\/]*>|((?!([^<>]*\\/>))[^<>]*>))";
    protected static final String TAG_SEARCH_4_4 = "<\\/";
    protected static final String TAG_SEARCH_4_5 = "[\\w\\W]*<\\/";
    protected static final String TAG_SEARCH_4_6 = "[\\w\\W]*)<\\/";
    //protected static final String TAG_SEARCH_4_7 = "\"[^<>\\/]*)>(";
    protected static final String TAG_SEARCH_4_7 = "\"([^<>\\/]*>|(?!([^<>]*\\/>))[^<>]*>))(";
    protected static final String TAG_SEARCH_4_7_2 = "\")([^<>\\/]*>|(?!([^<>]*\\/>))[^<>]*>))(";

    protected static final String NONE_SUPPORT = "\\/|\\^|\\$|\\(|\\)|\\[|\\]";

    protected static final Pattern pattern_none = Pattern.compile(NONE_SUPPORT);

    //setAttribute
    protected static final String SET_ATTR_1 = "=\"[^\"]*\"";
    //getAttributeValue
    protected static final String GET_ATTR_1 = "=\"([^\"]*)\"";
    //getAttributeMap
    //todo
    protected static final String GET_ATTRS_MAP = "([^\\s]*)=\"([^\"]*)\"";
    //eraseAttribute
    protected static final String ERASE_ATTR_1 = "=\"[^\"]*\"\\s";
    //setElementToQuarkTag
    //protected static final String SET_QUARK_1 = "<!--\\s@quark\\sid=\"";
    //protected static final String SET_QUARK_2 =
    //        "\"\\s-->(((?!(<!--\\s\\/@quark))[\\w\\W])*)<!--\\s\\/@quark\\s-->";
    //protected static final String SET_QUARK_3 = "<!-- @quark id=\"";
    //protected static final String SET_QUARK_4 = "\" -->";
    //protected static final String SET_QUARK_5 = "<!-- /@quark -->";

    //findCXTag
    protected static final String SEARCH_CX_1 = "<!--\\s@";
    protected static final String SEARCH_CX_2 = "\\s([^<>]*id=\"";
    protected static final String SEARCH_CX_3 = "\"[^<>]*)-->(((?!(<!--\\s\\/@";
    protected static final String SEARCH_CX_4 = "))[\\w\\W])*)<!--\\s\\/@";
    protected static final String SEARCH_CX_5 = "\\s-->";
    protected static final String SEARCH_CX_6 = "<!--\\s@([^<>]*)\\s[^<>]*id=\"";

    //setElementToCXTag
    protected static final String SET_CX_1 = "<!-- @";
    protected static final String SET_CX_2 = "-->";
    protected static final String SET_CX_3 = "<!-- /@";
    protected static final String SET_CX_4 = " -->";

    //setMonoInfo
    protected static final String SET_MONO_1 = "[^<>]*";

    //clean
    protected static final String CLEAN_1 = "<!--\\s@[^<>]*\\s[^<>]*(\\s)*-->";
    protected static final String CLEAN_2 = "<!--\\s\\/@[^<>]*(\\s)*-->";
    //tranCharXML
    protected static final String AND_1 = "&";
    protected static final String AND_2 = "&amp;";
    protected static final String LT_1 = "<";
    protected static final String LT_2 = "&lt;";
    protected static final String GT_1 = ">";
    protected static final String GT_2 = "&gt;";
    protected static final String QO_2 = "&quot;";
    protected static final String AP_1 = "'";
    protected static final String AP_2 = "&apos;";
    protected static final String EN_1 = "\\\\";
    protected static final String EN_2 = "\\\\\\\\";
    protected static final String DOL_1 = "\\$";
    protected static final String DOL_2 = "\\\\\\$";
    protected static final String PLUS_1 = "\\+";
    protected static final String PLUS_2 = "\\\\\\+";


    protected static final Pattern pattern_get_attrs_map = Pattern.compile(GET_ATTRS_MAP);

    //todo
    //2005.10.17 ADD START
    protected static final String BRAC_OPEN_1 = "\\(";
    protected static final String BRAC_OPEN_2 = "\\\\\\(";
    protected static final String BRAC_CLOSE_1 = "\\)";
    protected static final String BRAC_CLOSE_2 = "\\\\\\)";
    protected static final String SBRAC_OPEN_1 = "\\[";
    protected static final String SBRAC_OPEN_2 = "\\\\\\[";
    protected static final String SBRAC_CLOSE_1 = "\\]";
    protected static final String SBRAC_CLOSE_2 = "\\\\\\]";
    protected static final String CBRAC_OPEN_1 = "\\{";
    protected static final String CBRAC_OPEN_2 = "\\\\\\{";
    protected static final String CBRAC_CLOSE_1 = "\\}";
    protected static final String CBRAC_CLOSE_2 = "\\\\\\}";
    protected static final String COMMA_1 = "\\.";
    protected static final String COMMA_2 = "\\\\\\.";
    protected static final String VLINE_1 = "\\|";
    protected static final String VLINE_2 = "\\\\\\|";
    protected static final String QMARK_1 = "\\?";
    protected static final String QMARK_2 = "\\\\\\?";
    protected static final String ASTERISK_1 = "\\*";
    protected static final String ASTERISK_2 = "\\\\\\*";
    //2005.10.17 ADD END

    private static final Pattern pattern_en = Pattern.compile(EN_1);
    private static final Pattern pattern_dol = Pattern.compile(DOL_1);
    private static final Pattern pattern_plus = Pattern.compile(PLUS_1);
    private static final Pattern pattern_brac_open = Pattern.compile(BRAC_OPEN_1);
    private static final Pattern pattern_brac_close = Pattern.compile(BRAC_CLOSE_1);
    private static final Pattern pattern_sbrac_open = Pattern.compile(SBRAC_OPEN_1);
    private static final Pattern pattern_sbrac_close = Pattern.compile(SBRAC_CLOSE_1);
    private static final Pattern pattern_cbrac_open = Pattern.compile(CBRAC_OPEN_1);
    private static final Pattern pattern_cbrac_close = Pattern.compile(CBRAC_CLOSE_1);
    private static final Pattern pattern_comma = Pattern.compile(COMMA_1);
    private static final Pattern pattern_vline = Pattern.compile(VLINE_1);
    private static final Pattern pattern_qmark = Pattern.compile(QMARK_1);
    private static final Pattern pattern_asterisk = Pattern.compile(ASTERISK_1);

    private static final Pattern pattern_clean1 = Pattern.compile(CLEAN_1);
    private static final Pattern pattern_clean2 = Pattern.compile(CLEAN_2);

    protected String result = null;
    protected String pattern_cc = null;
    protected String element = null;

    private String pattern_cc_1;
    private String pattern_cc_1b;
    private String pattern_cc_1_1;
    private String pattern_cc_1_2;
    private String pattern_cc_2;
    private String pattern_cc_2_1;
    private String pattern_cc_2_2;

    protected int position = 0;
    protected int position2 = 0;

    protected String _elmName;
    protected String _attrName;
    protected String _attrValue;
    protected String _attrName1;
    protected String _attrValue1;
    protected String _attrName2;
    protected String _attrValue2;
    
    public Kernel() {
        root = new RootElement();
    }

    protected final void setDocument(String document) {
        this.root.setDocument(document);
    }

    protected String getDocument() {
        return root.getDocument();
    }

    protected final void setElement(Element elm) {
        this.root.setElement(elm);
    }

    protected final Element getElement() {
        return root.getElement();
    }

    protected Parser getParent() {
        return parent;
    }

    protected void setParent(Parser parent) {
        this.parent = parent;
    }

    protected final void setHook() {
        this.root.setHook(true);
    }

    protected final void setHook(boolean hook) {
        this.root.setHook(hook);
    }

    protected final boolean isHook() {
        return this.root.isHook();
    }

    protected final void setMonoHook() {
        this.root.setMonoHook(true);
    }

    protected final void setMonoHook(boolean hook) {
        this.root.setMonoHook(hook);
    }

    protected final boolean isMonoHook() {
        return this.root.isMonoHook();
    }

    protected final void addHookDocument(String addDocument) {
        this.root.setHookDocument(root.getHookDocument().append(addDocument));
    }

    protected final void setHookDocument(String hookDocument) {
        this.root.setHookDocument((new StringBuilder(hookScale)).append(hookDocument));
    }

    protected final String getHookDocument() {
        return root.getHookDocument().toString();
    }

    protected void setHookScale(int hookScale) {
        this.hookScale = hookScale;
    }

    protected void setCharacterEncoding(String enc) {
        this.root.setCharacterEncoding(enc);
    }

    protected final String getCharacterEncoding() {
        return this.root.getCharacterEncoding();
    }

    protected RootElement getRootElement() {
        return root;
    }

    /**
     * ファイルを読み込み、パースする
     *
     * @param filePath 入力ファイルの絶対パス
     * @param encoding 入力ファイルの文字コード
     */
    protected void read(String filePath, String encoding) {
        
        try {
            setCharacterEncoding(encoding);
            //ファイルのオープン
            FileInputStream fis = new FileInputStream(filePath);

            FileChannel channel = fis.getChannel();
            ByteBuffer bbuf = ByteBuffer.allocate((int)channel.size());
            //読込及び格納
            channel.read(bbuf);
            bbuf.clear();
            byte[] bytes = new byte[bbuf.capacity()];
            bbuf.get(bytes);
            channel.close();
            //ファイルのクローズ
            fis.close();

            this.setDocument(new String(bytes,encoding));

        } catch (FileNotFoundException e) {
            //FileNotFoundException時の処理
            e.printStackTrace();
            this.setDocument(EMPTY);
        } catch (Exception e) {
            //上記以外の例外時の処理
            e.printStackTrace();
            this.setDocument(EMPTY);
        }
        //this.setDocument(sb.toString());

        //System.out.println(this.getDocument());
    }

    /**
     * 要素名により、要素を検索する
     *
     * @param elmName 要素名
     * @return 要素
     */
    protected Element findElement(String elmName) {

        Element elm;

        //要素名にサポートしていない文字が含まれる場合
        //matcher = pattern_none.matcher(elmName);
        //if (matcher.find()) {
        //    return null;
        //}
        _elmName = matchRegex(elmName);

        //要素ありタグ検索用パターン
        sbuf.setLength(0);
        pattern_cc = sbuf.append(TAG_OPEN).append(_elmName)
                .append(TAG_SEARCH_1_3).toString();
        pattern = PatternCache.get(pattern_cc);
        //要素ありタグ検索
        matcher = pattern.matcher(this.getDocument());

        if (matcher.find()) {
            elm = findElementWithoutContent(elmName);
        } else {
            elm = findElementWithContent(elmName);
        }

        //初期化
        //matcher.reset();

        return elm;
    }

    protected Element findElementWithContent(String elmName) {
        Element elm;

        sbuf.setLength(0);
        pattern_cc = sbuf.append(TAG_OPEN).append(_elmName)
                .append(TAG_SEARCH_1_1).append(elmName).append(TAG_SEARCH_1_2).
                append(_elmName).append(TAG_CLOSE).toString();
        pattern = PatternCache.get(pattern_cc);
        //要素ありタグ検索
        matcher = pattern.matcher(this.getDocument());

        if (matcher.find()) {
            elm = new Element(elmName);
            //属性
            elm.setAttributes(matcher.group(1));
            //要素
            elm.setContent(matcher.group(2));
            //要素ありタグ検索用パターン
            elm.setPattern(pattern_cc);

        }else{
            throw new NoSuchElementException(elmName);
        }

        return elm;
    }

    protected Element findElementWithoutContent(String elmName) {
        Element elm;

        //空要素タグ検索用パターン
        sbuf.setLength(0);
        pattern_cc = sbuf.append(TAG_OPEN).append(_elmName)
                .append(TAG_SEARCH_1_3).toString();
        pattern = PatternCache.get(pattern_cc);
        //空要素タグ検索
        matcher = pattern.matcher(this.getDocument());
        if (matcher.find()) {
            elm = new Element(elmName);
            //属性
            elm.setAttributes(matcher.group(1));
            //空要素タグ検索用パターン
            elm.setPattern(pattern_cc);
        }else{
            throw new NoSuchElementException(elmName);
        }

        return elm;
    }

    /**
     * 要素名と属性により、要素を検索する
     *
     * @param elmName  要素の名前
     * @param attrName 属性名
     * @param attrValue 属性値
     * @return 要素
     */
    protected Element findElement(String elmName, String attrName, String attrValue) {

        Element elm;

        //要素名にサポートしていない文字が含まれる場合
        //matcher = pattern_none.matcher(elmName);
        //if (matcher.find()) {
        //    return null;
        //}
        _elmName = matchRegex(elmName);

        //属性名にサポートしていない文字が含まれる場合
        //matcher = pattern_none.matcher(attrName);
        //if (matcher.find()) {
        //    return null;
        //}
        _attrName = matchRegex(attrName);

        //属性値にサポートしていない文字が含まれる場合
        //matcher = pattern_none.matcher(attrValue);
        //if (matcher.find()) {
        //    return null;
        //}
        _attrValue = matchRegex(attrValue);

        //要素ありタグ検索用パターン
        sbuf.setLength(0);
        pattern_cc = sbuf.append(TAG_OPEN).append(_elmName)
                .append(TAG_SEARCH_2_1).append(_attrName).append(ATTR_EQ)
                .append(_attrValue).append(TAG_SEARCH_2_4_2).toString();
        pattern = PatternCache.get(pattern_cc);
        //要素ありタグ検索
        matcher = pattern.matcher(this.getDocument());

        if (matcher.find()) {
            elm = findElementWithContent(elmName, attrName, attrValue);
        } else {
            elm = findElementWithoutContent(elmName, attrName, attrValue);
        }

        //初期化
        //matcher.reset();

        return elm;
    }

    protected Element findElementWithContent(String elmName, String attrName, String attrValue) {
        Element elm;

        sbuf.setLength(0);
        pattern_cc = sbuf.append(TAG_OPEN).append(_elmName)
                .append(TAG_SEARCH_2_1).append(_attrName).append(ATTR_EQ)
                .append(_attrValue).append(TAG_SEARCH_2_2).append(_elmName)
                .append(TAG_SEARCH_1_2).append(_elmName).append(TAG_CLOSE).toString();

        //todo
        //System.out.println(pattern_cc);

        pattern = PatternCache.get(pattern_cc);
        //要素ありタグ検索
        matcher = pattern.matcher(this.getDocument());

        if (matcher.find()) {

            elm = new Element(elmName);
            //属性
            sbuf.setLength(0);
            elm.setAttributes(matcher.group(1));
            //要素
            elm.setContent(matcher.group(2));
            //要素ありタグ検索用パターン
            elm.setPattern(pattern_cc);

        } else {

            //todo

            int cnt = 0;

            sbuf.setLength(0);
            pattern_cc_1 = sbuf.append(TAG_OPEN).append(_elmName)
                    .append(TAG_SEARCH_2_1).append(_attrName).append(ATTR_EQ)
                    .append(_attrValue).append(TAG_SEARCH_2_4_2).toString();

            sbuf.setLength(0);
            pattern_cc_1b = sbuf.append(TAG_OPEN).append(_elmName)
                    .append(TAG_SEARCH_1_4).toString();

            sbuf.setLength(0);
            pattern_cc_1_1 = sbuf.append(TAG_OPEN).append(_elmName)
                    .append(TAG_SEARCH_2_1).append(_attrName).append(ATTR_EQ)
                    .append(_attrValue).append(TAG_SEARCH_4_7).toString();

            sbuf.setLength(0);
            pattern_cc_1_2 = sbuf.append(TAG_SEARCH_4_2).append(_elmName)
                    .append(TAG_SEARCH_4_3).toString();

            sbuf.setLength(0);
            pattern_cc_2 = sbuf.append(TAG_SEARCH_4_4).append(_elmName).append(TAG_CLOSE).toString();

            sbuf.setLength(0);
            pattern_cc_2_1 = sbuf.append(TAG_SEARCH_4_5).append(_elmName).append(TAG_CLOSE).toString();

            sbuf.setLength(0);
            pattern_cc_2_2 = sbuf.append(TAG_SEARCH_4_6).append(_elmName).append(TAG_CLOSE).toString();

            pattern = PatternCache.get(pattern_cc_1);
            //要素ありタグ検索
            matcher = pattern.matcher(this.getDocument());

            position = 0;
            //position2=0;

            sbuf.setLength(0);
            boolean res;

            while ((res = matcher.find(position)) || cnt > 0) {
                if (res) {

                    if(cnt > 0){

                        position2 = matcher.end();

                        pattern = PatternCache.get(pattern_cc_2);
                        matcher = pattern.matcher(this.getDocument());

                        res = matcher.find(position);

                        if (res) {

                            position = matcher.end();

                            if(position > position2){

                                if (cnt == 0) {
                                    sbuf.append(pattern_cc_1_1);
                                } else {
                                    sbuf.append(pattern_cc_1_2);
                                }

                                cnt += 1;

                                position = position2;
                            }else{
                                cnt -= 1;

                                if (cnt != 0) {
                                    sbuf.append(pattern_cc_2_1);
                                } else {
                                    sbuf.append(pattern_cc_2_2);
                                }

                                if (cnt == 0) {
                                    break;
                                }
                            }
                        }else{


                            if (cnt == 0) {
                                sbuf.append(pattern_cc_1_1);
                            } else {
                                sbuf.append(pattern_cc_1_2);
                            }

                            cnt += 1;

                            position = position2;
                        }
                    }else{

                        position = matcher.end();

                        if (cnt == 0) {
                            sbuf.append(pattern_cc_1_1);
                        } else {
                            sbuf.append(pattern_cc_1_2);
                        }

                        cnt += 1;
                    }

                    //System.out.println("CRE-A");

                } else {
                    pattern = PatternCache.get(pattern_cc_2);
                    matcher = pattern.matcher(this.getDocument());

                    res = matcher.find(position);

                    if (res) {
                        cnt -= 1;

                        if (cnt != 0) {
                            sbuf.append(pattern_cc_2_1);
                        } else {
                            sbuf.append(pattern_cc_2_2);
                        }

                        position = matcher.end();
                    }

                    //System.out.println("CRE-B");

                    if (!res) {
                        break;
                    }

                    if (cnt == 0) {
                        break;
                    }
                }

                pattern = PatternCache.get(pattern_cc_1b);
                matcher = pattern.matcher(this.getDocument());

            }

            pattern_cc = sbuf.toString();

            //todo
            //System.out.println("[" + pattern_cc + "]");
            //System.out.println("TestPRE");


            if (cnt != 0) {
                //return null;
                throw new NoSuchElementException(elmName,attrName,attrValue);
            }

            pattern = PatternCache.get(pattern_cc);
            matcher = pattern.matcher(this.getDocument());

            if (matcher.find()) {
                elm = new Element(elmName);
                //属性
                sbuf.setLength(0);
                elm.setAttributes(matcher.group(1).substring(0,matcher.group(1).length()-1));
                //要素
                elm.setContent(matcher.group(4));
                //要素ありタグ検索用パターン
                elm.setPattern(pattern_cc);

                //todo
                //System.out.println("[" + elm.getAttributes() + "]");
                //System.out.println("[" + elm.getContent() + "]");
            }else{
                throw new NoSuchElementException(elmName,attrName,attrValue);
            }

        }

        return elm;
    }

    protected Element findElementWithoutContent(String elmName, String attrName, String attrValue) {
        Element elm;

        elm = _findElementWithoutContent(elmName, attrName, attrValue, TAG_SEARCH_2_3_2);

        return elm;
    }

    protected final Element _findElementWithoutContent(String elmName, String attrName, String attrValue, String closer) {
        Element elm;

        //空要素タグ検索用パターン
        sbuf.setLength(0);
        pattern_cc = sbuf.append(TAG_OPEN).append(_elmName)
                .append(TAG_SEARCH_2_1).append(_attrName).append(ATTR_EQ)
                .append(_attrValue).append(closer) //.append(TAG_CLOSE2)
                .toString();
        pattern = PatternCache.get(pattern_cc);
        //空要素タグ検索
        matcher = pattern.matcher(this.getDocument());
        if (matcher.find()) {
            elm = new Element(elmName);
            //属性
            sbuf.setLength(0);
            elm.setAttributes(matcher.group(1));
            //空要素タグ検索用パターン
            elm.setPattern(pattern_cc);
        }else{
            throw new NoSuchElementException(elmName,attrName,attrValue);
        }

        return elm;
    }

    /**
     * 属性(属性名="属性値")により、要素を検索する
     *
     * @param attrName 属性名
     * @param attrValue 属性値
     * @return 要素
     */
    protected Element findElement(String attrName, String attrValue) {

        Element elm;

        //属性名にサポートしていない文字が含まれる場合
        //matcher = pattern_none.matcher(attrName);
        //if (matcher.find()) {
        //    return null;
        //}
        _attrName = matchRegex(attrName);

        //属性値にサポートしていない文字が含まれる場合
        //matcher = pattern_none.matcher(attrValue);
        //if (matcher.find()) {
        //    return null;
        //}
        _attrValue = matchRegex(attrValue);

        sbuf.setLength(0);
        pattern_cc = sbuf.append(TAG_SEARCH_3_1).append(_attrName).append(ATTR_EQ)
                .append(_attrValue).append(TAG_SEARCH_2_4).toString();
        pattern = PatternCache.get(pattern_cc);

        matcher = pattern.matcher(this.getDocument());

        if (matcher.find()) {
            elm = findElement(matcher.group(1), attrName, attrValue);
        } else {
            elm = findElementWithoutContent(attrName, attrValue);
        }

        //初期化

        return elm;
    }


    protected Element findElementWithoutContent(String attrName, String attrValue) {

        Element elm;

        sbuf.setLength(0);
        pattern_cc = sbuf.append(TAG_SEARCH_3_1).append(_attrName).append(ATTR_EQ)
                .append(_attrValue).append(TAG_SEARCH_3_2).toString();
        pattern = PatternCache.get(pattern_cc);

        matcher = pattern.matcher(this.getDocument());

        if (matcher.find()) {
            elm = findElement(matcher.group(1), attrName, attrValue);
        }else{
            throw new NoSuchElementException(attrName,attrValue);
        }

        return elm;
    }

    /**
     * 要素名と属性1と属性2により、要素を検索する
     * @param elmName  要素の名前
     * @param attrName1 属性名1
     * @param attrValue1 属性値2
     * @param attrName2 属性名2
     * @param attrValue2 属性値2
     * @return 要素
     */
    protected Element findElement(String elmName,
                                  String attrName1, String attrValue1,String attrName2, String attrValue2) {

        Element elm;

        //要素名にサポートしていない文字が含まれる場合
        //matcher = pattern_none.matcher(elmName);
        //if (matcher.find()) {
        //    return null;
        //}
        _elmName = matchRegex(elmName);

        //属性名にサポートしていない文字が含まれる場合
        //matcher = pattern_none.matcher(attrName1);
        //if (matcher.find()) {
        //    return null;
        //}
        _attrName1 = matchRegex(attrName1);

        //属性名にサポートしていない文字が含まれる場合
        //matcher = pattern_none.matcher(attrName2);
        //if (matcher.find()) {
        //    return null;
        //}
        _attrName2 = matchRegex(attrName2);

        //属性値にサポートしていない文字が含まれる場合
        //matcher = pattern_none.matcher(attrValue1);
        //if (matcher.find()) {
        //    return null;
        //}
        _attrValue1 = matchRegex(attrValue1);

        //属性値にサポートしていない文字が含まれる場合
        //matcher = pattern_none.matcher(attrValue2);
        //if (matcher.find()) {
        //    return null;
        //}
        _attrValue2 = matchRegex(attrValue2);

        //要素ありタグ検索用パターン
        sbuf.setLength(0);
        pattern_cc = sbuf.append(TAG_OPEN).append(_elmName)
                .append(TAG_SEARCH_2_1_2).append(_attrName1).append(ATTR_EQ)
                .append(_attrValue1).append(TAG_SEARCH_2_6).append(_attrName2).append(ATTR_EQ)
                .append(_attrValue2).append(TAG_SEARCH_2_7).append(_attrName2).append(ATTR_EQ)
                .append(_attrValue2).append(TAG_SEARCH_2_6).append(_attrName1).append(ATTR_EQ)
                .append(_attrValue1).append(TAG_SEARCH_2_4_2_2).toString();

        //System.out.println("3[" + pattern_cc + "]");

        pattern = PatternCache.get(pattern_cc);
        //要素ありタグ検索
        matcher = pattern.matcher(this.getDocument());

        if (matcher.find()) {
            elm = findElementWithContent(elmName, attrName1, attrValue1,attrName2,attrValue2);
        } else {
            elm = findElementWithoutContent(elmName, attrName1, attrValue1,attrName2,attrValue2);
        }

        //初期化
        //matcher.reset();

        return elm;
    }


    protected Element findElementWithContent(String elmName,
                                             String attrName1, String attrValue1,String attrName2,String attrValue2 ) {
        //System.out.println("入ってます");

        Element elm = null;

        sbuf.setLength(0);
        pattern_cc = sbuf.append(TAG_OPEN).append(_elmName)
                .append(TAG_SEARCH_2_1_2).append(attrName1).append(ATTR_EQ)
                .append(_attrValue1).append(TAG_SEARCH_2_6).append(_attrName2).append(ATTR_EQ)
                .append(_attrValue2).append(TAG_SEARCH_2_7).append(_attrName2).append(ATTR_EQ)
                .append(_attrValue2).append(TAG_SEARCH_2_6).append(_attrName1).append(ATTR_EQ)
                .append(_attrValue1).append(TAG_SEARCH_2_2_2).append(_elmName)
                .append(TAG_SEARCH_1_2).append(_elmName).append(TAG_CLOSE).toString();

        //System.out.println("4[" + pattern_cc + "]");

        pattern = PatternCache.get(pattern_cc);
        //要素ありタグ検索
        matcher = pattern.matcher(this.getDocument());

        if (matcher.find()) {

            elm = new Element(elmName);
            //属性
            sbuf.setLength(0);
            elm.setAttributes(matcher.group(1));
            //要素
            elm.setContent(matcher.group(2));
            //要素ありタグ検索用パターン
            elm.setPattern(pattern_cc);

        } else {

            //todo

            int cnt = 0;

            sbuf.setLength(0);
            pattern_cc_1 = sbuf.append(TAG_OPEN).append(_elmName)
                .append(TAG_SEARCH_2_1_2).append(_attrName1).append(ATTR_EQ)
                .append(_attrValue1).append(TAG_SEARCH_2_6).append(_attrName2).append(ATTR_EQ)
                .append(_attrValue2).append(TAG_SEARCH_2_7).append(_attrName2).append(ATTR_EQ)
                .append(_attrValue2).append(TAG_SEARCH_2_6).append(_attrName1).append(ATTR_EQ)
                .append(_attrValue1).append(TAG_SEARCH_2_4_2_2).toString();

            //System.out.println("5[" + pattern_cc_1 +"]");

            sbuf.setLength(0);
            pattern_cc_1b = sbuf.append(TAG_OPEN).append(_elmName)
                    .append(TAG_SEARCH_1_4).toString();

            sbuf.setLength(0);
            pattern_cc_1_1 = sbuf.append(TAG_OPEN).append(_elmName)
                    .append(TAG_SEARCH_2_1_2).append(_attrName1).append(ATTR_EQ)
                    .append(_attrValue1).append(TAG_SEARCH_2_6).append(_attrName2).append(ATTR_EQ)
                    .append(_attrValue2).append(TAG_SEARCH_2_7).append(_attrName2).append(ATTR_EQ)
                    .append(_attrValue2).append(TAG_SEARCH_2_6).append(_attrName1).append(ATTR_EQ)
                    .append(_attrValue1).append(TAG_SEARCH_4_7_2).toString();

            //System.out.println("5[" + pattern_cc_1_1 +"]");

            sbuf.setLength(0);

            pattern_cc_1_2 = sbuf.append(TAG_SEARCH_4_2).append(_elmName)
                    .append(TAG_SEARCH_4_3).toString();

            sbuf.setLength(0);
            pattern_cc_2 = sbuf.append(TAG_SEARCH_4_4).append(_elmName).append(TAG_CLOSE).toString();

            sbuf.setLength(0);
            pattern_cc_2_1 = sbuf.append(TAG_SEARCH_4_5).append(_elmName).append(TAG_CLOSE).toString();

            sbuf.setLength(0);
            pattern_cc_2_2 = sbuf.append(TAG_SEARCH_4_6).append(_elmName).append(TAG_CLOSE).toString();

            pattern = PatternCache.get(pattern_cc_1);
            //要素ありタグ検索
            matcher = pattern.matcher(this.getDocument());

            position = 0;
            //position2 = 0;

            sbuf.setLength(0);
            boolean res;

            while ((res = matcher.find(position)) || cnt > 0) {
                if (res) {

                    if(cnt > 0){

                        position2 = matcher.end();

                        pattern = PatternCache.get(pattern_cc_2);
                        matcher = pattern.matcher(this.getDocument());

                        res = matcher.find(position);

                        if (res) {

                            position = matcher.end();

                            if(position > position2){

                                if (cnt == 0) {
                                    sbuf.append(pattern_cc_1_1);
                                } else {
                                    sbuf.append(pattern_cc_1_2);
                                }

                                cnt += 1;

                                position = position2;
                            }else{
                                cnt -= 1;

                                if (cnt != 0) {
                                    sbuf.append(pattern_cc_2_1);
                                } else {
                                    sbuf.append(pattern_cc_2_2);
                                }

                                if (cnt == 0) {
                                    break;
                                }
                            }
                        }else{

                            if (cnt == 0) {
                                sbuf.append(pattern_cc_1_1);
                            } else {
                                sbuf.append(pattern_cc_1_2);
                            }

                            cnt += 1;

                            position = position2;
                        }
                    }else{
                        position = matcher.end();

                        if (cnt == 0) {
                            sbuf.append(pattern_cc_1_1);
                        } else {
                            sbuf.append(pattern_cc_1_2);
                        }

                        cnt += 1;
                    }
                } else {
                    pattern = PatternCache.get(pattern_cc_2);
                    matcher = pattern.matcher(this.getDocument());

                    res = matcher.find(position);

                    if (res) {
                        cnt -= 1;

                        if (cnt != 0) {
                            sbuf.append(pattern_cc_2_1);
                        } else {
                            sbuf.append(pattern_cc_2_2);
                        }

                        position = matcher.end();
                    }

                    if (cnt == 0) {
                        break;
                    }

                    if (!res) {
                        break;
                    }


                }

                pattern = PatternCache.get(pattern_cc_1b);
                matcher = pattern.matcher(this.getDocument());

            }

            pattern_cc = sbuf.toString();

            //System.out.println("2[" + pattern_cc + "]");
            //System.out.println("TestPRE");


            if (cnt != 0) {
                //return null;
                throw new NoSuchElementException(elmName,attrName1,attrValue1,attrName2,attrValue2);
            }

            pattern = PatternCache.get(pattern_cc);
            matcher = pattern.matcher(this.getDocument());

            if (matcher.find()) {
                elm = new Element(elmName);
                //属性
                sbuf.setLength(0);
                elm.setAttributes(matcher.group(1).substring(0,matcher.group(1).length()));
                //要素
                elm.setContent(matcher.group(4));
                //要素ありタグ検索用パターン
                elm.setPattern(pattern_cc);

                //System.out.println("[" + elm.getAttributes() + "]");
                //System.out.println("[" + elm.getContent() + "]");
            }

        }

        return elm;
    }

    protected Element findElementWithoutContent(String elmName,
                                                String attrName1, String attrValue1,String attrName2, String attrValue2) {
        Element elm;

        elm = _findElementWithoutContent(elmName, attrName1, attrValue1,attrName2,attrValue2,TAG_SEARCH_2_3_2_2);

        return elm;
    }

    protected final Element _findElementWithoutContent(String elmName,
                                                String attrName1, String attrValue1,String attrName2,String attrValue2,
                                                String closer) {
        //System.out.println("入ってません");

        Element elm;

        //空要素タグ検索用パターン
        sbuf.setLength(0);
        pattern_cc = sbuf.append(TAG_OPEN).append(_elmName)
                .append(TAG_SEARCH_2_1_2).append(_attrName1).append(ATTR_EQ)
                .append(_attrValue1).append(TAG_SEARCH_2_6).append(_attrName2).append(ATTR_EQ)
                .append(_attrValue2).append(TAG_SEARCH_2_7).append(_attrName2).append(ATTR_EQ)
                .append(_attrValue2).append(TAG_SEARCH_2_6).append(_attrName1).append(ATTR_EQ)
                .append(_attrValue1).append(closer) //.append(TAG_CLOSE2)
                .toString();
        pattern = PatternCache.get(pattern_cc);
        //空要素タグ検索
        matcher = pattern.matcher(this.getDocument());
        if (matcher.find()) {
            elm = new Element(elmName);
            //属性
            sbuf.setLength(0);
            elm.setAttributes(matcher.group(1));
            //空要素タグ検索用パターン
            elm.setPattern(pattern_cc);
        }else{
            throw new NoSuchElementException(elmName,attrName1,attrValue1,attrName2,attrValue2);
        }

        return elm;
    }

    /**
     * 属性1と属性2(属性名="属性値")により、要素を検索する
     *
     * @param attrName1 属性名1
     * @param attrValue1 属性値1
     * @param attrName2 属性名2
     * @param attrValue2 属性値2
     * @return 要素
     */
    protected Element findElement(String attrName1, String attrValue1,
                                  String attrName2, String attrValue2) {

        Element elm;

        //属性名にサポートしていない文字が含まれる場合
        //matcher = pattern_none.matcher(attrName1);
        //if (matcher.find()) {
        //    return null;
        //}
        _attrName1 = matchRegex(attrName1);

        //属性名にサポートしていない文字が含まれる場合
        //matcher = pattern_none.matcher(attrName2);
        //if (matcher.find()) {
        //    return null;
        //}
        _attrName2 = matchRegex(attrName2);

        //属性値にサポートしていない文字が含まれる場合
        //matcher = pattern_none.matcher(attrValue1);
        //if (matcher.find()) {
        //    return null;
        //}
        _attrValue1 = matchRegex(attrValue1);

        //属性値にサポートしていない文字が含まれる場合
        matcher = pattern_none.matcher(attrValue2);
        //if (matcher.find()) {
        //    return null;
        //}
        _attrValue2 = matchRegex(attrValue2);

        sbuf.setLength(0);
        pattern_cc = sbuf.append(TAG_SEARCH_3_1_2_2).append(_attrName1).append(ATTR_EQ)
                .append(_attrValue1).append(TAG_SEARCH_2_6).append(_attrName2).append(ATTR_EQ)
                .append(_attrValue2).append(TAG_SEARCH_2_7).append(_attrName2).append(ATTR_EQ)
                .append(_attrValue2).append(TAG_SEARCH_2_6).append(_attrName1).append(ATTR_EQ)
                .append(_attrValue1).append(TAG_SEARCH_2_4_2_2).toString();
        pattern = PatternCache.get(pattern_cc);

        matcher = pattern.matcher(this.getDocument());

        if (matcher.find()) {
            elm = findElement(matcher.group(1), attrName1, attrValue1,attrName2, attrValue2);
        } else {
            elm = findElementWithoutContent(attrName1, attrValue1,attrName2, attrValue2);
        }

        //初期化

        return elm;
    }

    protected Element findElementWithoutContent(String attrName1,String attrValue1,
                                                String attrName2,String attrValue2) {

        Element elm;

        sbuf.setLength(0);
        pattern_cc = sbuf.append(TAG_SEARCH_3_1_2_2).append(_attrName1).append(ATTR_EQ)
                .append(_attrValue1).append(TAG_SEARCH_2_6).append(_attrName2).append(ATTR_EQ)
                .append(_attrValue2).append(TAG_SEARCH_2_7).append(_attrName2).append(ATTR_EQ)
                .append(_attrValue2).append(TAG_SEARCH_2_6).append(_attrName1).append(ATTR_EQ)
                .append(_attrValue1).append(TAG_SEARCH_3_2_2_2).toString();
        pattern = PatternCache.get(pattern_cc);

        matcher = pattern.matcher(this.getDocument());

        if (matcher.find()) {
            elm = findElement(matcher.group(1), attrName1,attrValue1,attrName2,attrValue2);
        }else{
            throw new NoSuchElementException(attrName1,attrValue1,attrName2,attrValue2);
        }

        return elm;
    }

    /**
     * 要素名を編集する
     *
     * @param elm     要素
     * @param elmName 要素名
     */
    protected void setElementName(Element elm, String elmName) {

        result = elm.getName();

        elm.setName(elmName);
        //タグ検索用パターン
        pattern = PatternCache.get(elm.getPattern());
        //タグ検索
        matcher = pattern.matcher(this.getDocument());
        if (elm.empty()) {
            //要素ありタグの場合
            sbuf.setLength(0);
            this.setDocument(matcher.replaceFirst(sbuf.append(TAG_OPEN)
                    .append(elm.getName()).append(elm.getAttributes()).append(TAG_CLOSE)
                    .append(elm.getContent()).append(TAG_OPEN3).append(elm.getName())
                    .append(TAG_CLOSE).toString()));
        } else {
            //空要素タグの場合
            sbuf.setLength(0);
            this.setDocument(matcher.replaceFirst(sbuf.append(TAG_OPEN)
                    .append(elm.getName()).append(elm.getAttributes()).append(TAG_CLOSE2)
                    .toString()));
        }

        //パターンの更新
        if (!result.equals(elmName)) {
            sbuf.setLength(0);
            pattern_cc = sbuf.append(TAG_OPEN).append(result).toString();
            pattern = PatternCache.get(pattern_cc);
            matcher = pattern.matcher(elm.getPattern());
            sbuf.setLength(0);
            elm.setPattern(matcher.replaceAll(sbuf.append(TAG_OPEN).append(elmName).toString()));

            if (elm.empty()) {
                sbuf.setLength(0);
                pattern_cc = sbuf.append(TAG_OPEN4).append(result).toString();
                pattern = PatternCache.get(pattern_cc);
                matcher = pattern.matcher(elm.getPattern());
                sbuf.setLength(0);
                elm.setPattern(matcher.replaceAll(sbuf.append(TAG_OPEN4).append(elmName).toString()));
            }
        }

    }

    /**
     * 要素の属性を編集する
     *
     * @param elm       要素
     * @param attrName  属性名
     * @param attrValue 属性値
     */
    protected void setAttribute(Element elm, String attrName, String attrValue) {

        if (!elm.cx()) {

            attrValue = _editAttributes(elm,attrName,attrValue);


            _editDocument(elm);

            //パターンの更新
            _editPattern(elm,attrName,attrValue);

        }
    }

    protected String _editAttributes(Element elm,String attrName, String attrValue){
        attrValue = tranCharXML(attrValue);
        //属性検索用パターン
        sbuf.setLength(0);
        pattern = PatternCache.get(sbuf.append(attrName).append(SET_ATTR_1)
                .toString());

        //System.out.println(elm.getAttributes());
        //属性検索
        matcher = pattern.matcher(elm.getAttributes());

        sbuf.setLength(0);
        //検索対象属性の存在判定
        if (matcher.find()) {
            //todo
            //System.out.println(matcher.group(0));

            attrValue = matchRegex(attrValue);
            //属性の置換
            result = matcher.replaceAll(sbuf.append(attrName)
                    .append(ATTR_EQ).append(attrValue).append(DOUBLE_QUATATION)
                    .toString());
            attrValue = matchRegex(attrValue);
            //todo
            //System.out.println("res1:" + result);

        } else {
            //属性文字列の最後に新規の属性を追加する
            if (!EMPTY.equals(elm.getAttributes()) && !EMPTY.equals(elm.getAttributes().trim())) {
                sbuf.setLength(0);
                result = sbuf.append(SPACE).append(elm.getAttributes().trim())
                        .toString();
            } else {
                result = EMPTY;
            }
            sbuf.setLength(0);
            result = sbuf.append(result).append(SPACE).append(attrName)
                    .append(ATTR_EQ).append(attrValue).append(DOUBLE_QUATATION)
                    .toString();
            attrValue = matchRegex(attrValue);
            attrValue = matchRegex(attrValue);
        }
        elm.setAttributes(result);

        return attrValue;
    }

    protected void _editDocument(Element elm){
        _editDocument(elm,TAG_CLOSE2);
    }

    protected final void _editDocument(Element elm,String closer){
        result = matchRegex(elm.getAttributes());

        //System.out.println("res:" + result);

        if (elm.empty()) {
            //要素ありタグの場合
            element = elm.getContent();

            element = matchRegex(element);

            //タグ検索用パターン
            pattern = PatternCache.get(elm.getPattern());
            //タグ検索
            matcher = pattern.matcher(this.getDocument());
            sbuf.setLength(0);
            this.setDocument(matcher.replaceFirst(sbuf.append(TAG_OPEN)
                    .append(elm.getName()).append(result).append(TAG_CLOSE)
                    .append(element).append(TAG_OPEN3).append(elm.getName())
                    .append(TAG_CLOSE).toString()));
        } else {
            //空要素タグの場合
            //タグ検索用パターン
            pattern = PatternCache.get(elm.getPattern());
            //タグ検索
            matcher = pattern.matcher(this.getDocument());
            sbuf.setLength(0);
            this.setDocument(matcher.replaceFirst(sbuf.append(TAG_OPEN)
                    .append(elm.getName()).append(result).append(closer)
                    .toString()));
        }
    }

    protected final void _editPattern(Element elm,String attrName,String attrValue){

        sbuf.setLength(0);
        pattern_cc = sbuf.append(attrName).append(SET_ATTR_1).toString();
        pattern = PatternCache.get(pattern_cc);
        matcher = pattern.matcher(elm.getPattern());
        sbuf.setLength(0);
        elm.setPattern(matcher.replaceFirst(sbuf.append(attrName).append(ATTR_EQ).append(attrValue)
                .append(DOUBLE_QUATATION).toString()));
    }

    /**
     * 要素を属性名で検索し、属性値を得る
     *
     * @param elm      要素
     * @param attrName 属性名
     * @return 属性値
     */
    protected String getAttributeValue(Element elm, String attrName) {

         return _getAttributeValue(elm,attrName);
    }

    protected String _getAttributeValue(Element elm, String attrName){

        //属性検索用パターン
        sbuf.setLength(0);
        pattern = PatternCache.get(sbuf.append(attrName).append(GET_ATTR_1)
                      .toString());
        matcher = pattern.matcher(elm.getAttributes());

        if (matcher.find()) {
            result = restoreCharXML(matcher.group(1));
        }

        return result;

    }

    /**
     * 属性マップを取得する
     * @param elm 要素
     * @return 属性マップ
     */
    protected AttributeMap getAttributeMap(Element elm){

        AttributeMap attrs = new AttributeMap();
        
        matcher = pattern_get_attrs_map.matcher(elm.getAttributes());

        while(matcher.find()){
            attrs.put(matcher.group(1),restoreCharXML(matcher.group(2)));
            System.out.println(matcher.group(1));
            System.out.println(matcher.group(2));
        }

        return attrs;
    }

    /**
     * 要素の内容をセットする
     *
     * @param elm 要素
     * @param content 要素の内容
     * @param entityRef エンティティ参照フラグ
     */
    protected void setContent(Element elm, String content, boolean entityRef) {

        if (!elm.cx()) {

            //要素ありタグの場合
            if (elm.empty()) {
                elm.setContent(content);

                if (entityRef) {
                    content = tranCharXMLContent(content, elm.getName());
                    content = matchRegex(content);
                } else {
                    content = matchRegex(content);
                }

                //タグ検索パターン
                pattern = PatternCache.get(elm.getPattern());
                //タグ置換
                matcher = pattern.matcher(this.getDocument());
                sbuf.setLength(0);
                this.setDocument(matcher.replaceFirst(sbuf.append(TAG_OPEN)
                        .append(elm.getName()).append(elm.getAttributes()).append(TAG_CLOSE)
                        .append(content).append(TAG_OPEN3).append(elm.getName())
                        .append(TAG_CLOSE).toString()));
            }
            //初期化
            //matcher.reset();
            //matcher = null;
            //pattern = null;
        } else {
            elm.setContent(content);

            if (entityRef) {
                content = tranCharXMLContent(content, elm.getName());
                content = matchRegex(content);
            } else {
                content = matchRegex(content);
            }

            pattern = PatternCache.get(elm.getPattern());
            matcher = pattern.matcher(this.getDocument());
            //タグ置換
            sbuf.setLength(0);
            pattern_cc = sbuf.append(SET_CX_1).append(elm.getName())
                    .append(SPACE).append(elm.getAttributes()).append(SET_CX_2)
                    .append(content).append(SET_CX_3).append(elm.getName())
                    .append(SET_CX_4).toString();
            this.setDocument(matcher.replaceFirst(pattern_cc));

        }
    }

    /**
     * 要素の内容をセットする
     *
     * @param elm     要素
     * @param content 要素の内容
     */
    protected void setContent(Element elm, String content) {
        setContent(elm, content, true);
    }

    /**
     * 要素の内容を取得する
     *
     * @param elm 要素
     * @return 要素の内容
     */
    protected String getContent(Element elm) {
        if (!elm.cx()) {
            //要素ありタグの場合
            if (elm.empty()) {
                result = restoreCharXMLContent(elm.getContent(), elm.getName());
            }
        }

        return result;
    }

    /**
     * 要素の属性を消す
     * @param elm 要素
     * @param attrName 属性名
     */
    protected void eraseAttribute(Element elm, String attrName) {

        if (!elm.cx()) {
            result = elm.getAttributes();

            //属性検索用パターン
            sbuf.setLength(0);
            pattern = PatternCache.get(sbuf.append(attrName).append(ERASE_ATTR_1)
                    .toString());
            //属性検索
            matcher = pattern.matcher(elm.getAttributes());

            //検索対象属性の存在判定
            if (matcher.find()) {
                //属性の置換
                result = matcher.replaceFirst(EMPTY);

                elm.setAttributes(result);
            } else {
                //属性検索用パターン
                sbuf.setLength(0);
                pattern = PatternCache.get(sbuf.append(attrName).append(SET_ATTR_1)
                        .toString());
                //属性検索
                matcher = pattern.matcher(elm.getAttributes());
                //検索対象属性の存在判定
                if (matcher.find()) {
                    //属性の置換
                    result = matcher.replaceFirst(EMPTY);

                    elm.setAttributes(result);
                }
            }
            //タグ検索用パターン
            pattern = PatternCache.get(elm.getPattern());
            //タグ検索
            matcher = pattern.matcher(this.getDocument());
            if (elm.empty()) {
                //要素ありタグの場合
                sbuf.setLength(0);
                element = matchRegex(elm.getContent());
                this.setDocument(matcher.replaceFirst(sbuf.append(TAG_OPEN)
                        .append(elm.getName()).append(result).append(TAG_CLOSE)
                        .append(element).append(TAG_OPEN3)
                        .append(elm.getName()).append(TAG_CLOSE).toString()));
            } else {
                //空要素タグの場合
                sbuf.setLength(0);
                this.setDocument(matcher.replaceFirst(sbuf.append(TAG_OPEN)
                        .append(elm.getName()).append(result).append(TAG_CLOSE2)
                        .toString()));
            }

            //パターンの更新
            sbuf.setLength(0);
            pattern_cc = sbuf.append(attrName).append(SET_ATTR_1).toString();
            pattern = PatternCache.get(pattern_cc);
            matcher = pattern.matcher(elm.getPattern());
            sbuf.setLength(0);
            elm.setPattern(matcher.replaceFirst(EMPTY));

        }
    }

    /**
     * 要素を消す
     *
     * @param elm 要素
     */
    protected void eraseElement(Element elm) {

        if (!elm.cx()) {
            replace(elm, EMPTY);
        } else {
            replace(elm, EMPTY);
        }

    }

    protected Element findCXTag(String elmName, String id) {
        Element elm = null;

        //CXタグ検索用パターン
        sbuf.setLength(0);
        pattern_cc = sbuf.append(SEARCH_CX_1).append(elmName).append(SEARCH_CX_2)
                .append(id).append(SEARCH_CX_3).append(elmName).append(SEARCH_CX_4)
                .append(elmName).append(SEARCH_CX_5).toString();
        pattern = PatternCache.get(pattern_cc);
        //CXタグ検索
        matcher = pattern.matcher(this.getDocument());
        if (matcher.find()) {
            elm = new Element(elmName);
            elm.setCx(true);
            elm.setAttributes(matcher.group(1));
            elm.setContent(matcher.group(2));
            elm.setPattern(pattern_cc);
        }

        return elm;
    }

    /**
     * ID属性でCXタグを検索する
     *
     * @param id ID属性値
     * @return 要素
     */
    protected Element findCXTag(String id) {
        Element elm = null;

        sbuf.setLength(0);
        pattern_cc = sbuf.append(SEARCH_CX_6).append(id)
                .append(DOUBLE_QUATATION).toString();
        pattern = PatternCache.get(pattern_cc);
        matcher = pattern.matcher(this.getDocument());

        if (matcher.find()) {
            elm = findCXTag(matcher.group(1), id);
        }

        return elm;
    }

    /**
     * 要素を置換する
     *
     * @param elm             要素
     * @param replaceDocument 置換文字列
     */
    public final void replace(Element elm, String replaceDocument) {

        //文字コード変換
        replaceDocument = matchRegex(replaceDocument);

        //タグ置換パターン
        pattern = PatternCache.get(elm.getPattern());
        //タグ置換
        matcher = pattern.matcher(this.getDocument());
        this.setDocument(matcher.replaceFirst(replaceDocument));

        //初期化
        //matcher.reset();
    }

    /**
     * XMLをコンソールに出力する
     */
    protected void print() {
        if (isHook()) {
            //フック判定がTRUEの場合
            if (getElement().cx()) {
                //hookgetDocument().append(SET_QUARK_3).append(tag.getAttributes())
                // .append(SET_QUARK_4).append(getDocument()).append(SET_QUARK_5);
                //this.root.setHookDocument(this.root.getHookDocument().append(SET_CX_1).append(getElement().getName())
                //        .append(SPACE).append(getElement().getAttributes()).append(SET_CX_2)
                //        .append(getDocument()).append(SET_CX_3).append(getElement().getName())
                //        .append(SET_CX_4));
                this.root.setHookDocument(this.root.getHookDocument().append(SET_CX_1)
                        .append(this.root.getVariableElement().getName())
                        .append(SPACE).append(this.root.getVariableElement().getAttributes()).append(SET_CX_2)
                        .append(getDocument()).append(SET_CX_3)
                        .append(this.root.getVariableElement().getName())
                        .append(SET_CX_4));
            } else {
                //this.root.setHookDocument(this.root.getHookDocument().append(TAG_OPEN).append(getElement().getName())
                //        .append(getElement().getAttributes()).append(TAG_CLOSE).append(getDocument())
                //        .append(TAG_OPEN3).append(getElement().getName()).append(TAG_CLOSE));
                this.root.setHookDocument(this.root.getHookDocument().append(TAG_OPEN)
                        .append(this.root.getVariableElement().getName())
                        .append(root.getVariableElement().getAttributes()).append(TAG_CLOSE).append(getDocument())
                        .append(TAG_OPEN3).append(root.getVariableElement().getName()).append(TAG_CLOSE));
            }
            this.root.setVariableElement(new Element(this.root.getElement()));
        } else {
            if (isMonoHook()) {
                this.root.setHookDocument(this.root.getHookDocument().append(getDocument()));
            } else {

                //expire();

                //フック判定がFALSEの場合
                clean();
            }
        }
    }

    protected final void clean() {

        //Quark開始タグ置換
        pattern = pattern_clean1;
        matcher = pattern.matcher(getDocument());
        this.setDocument(matcher.replaceAll(EMPTY));
        //Quark終了タグ置換
        pattern = pattern_clean2;
        matcher = pattern.matcher(getDocument());
        this.setDocument(matcher.replaceAll(EMPTY));

        //sbuf.setLength(0);
        this.setDocument(getDocument() + "<!-- Powered by Meteor (C)Yasumasa Ashida -->");
        //初期化
        //matcher.reset();
    }


    protected abstract void setMonoInfo(Element elm);

    /**
     * 正規表現対象文字を変換する
     *
     * @param element 入力文字列
     * @return 出力文字列
     */
    protected final String matchRegex(String element) {
        //「\」->[\\]
        _matcher = pattern_en.matcher(element);
        element = _matcher.replaceAll(EN_2);
        //「$」->「\$」
        _matcher = pattern_dol.matcher(element);
        element = _matcher.replaceAll(DOL_2);
        //「+」->「\+」
        _matcher = pattern_plus.matcher(element);
        element = _matcher.replaceAll(PLUS_2);

        //todo
        //2005.10.17 ADD START
        //「(」->「\(」
        _matcher = pattern_brac_open.matcher(element);
        element = _matcher.replaceAll(BRAC_OPEN_2);
        //「)」->「\)」
        _matcher = pattern_brac_close.matcher(element);
        element = _matcher.replaceAll(BRAC_CLOSE_2);
        //「[」->「\[」
        _matcher = pattern_sbrac_open.matcher(element);
        element = _matcher.replaceAll(SBRAC_OPEN_2);
        //「]」->「\]」
        _matcher = pattern_sbrac_close.matcher(element);
        element = _matcher.replaceAll(SBRAC_CLOSE_2);
        //「{」->「\{」
        _matcher = pattern_cbrac_open.matcher(element);
        element = _matcher.replaceAll(CBRAC_OPEN_2);
        //「}」->「\}」
        _matcher = pattern_cbrac_close.matcher(element);
        element = _matcher.replaceAll(CBRAC_CLOSE_2);
        //「.」->「\.」
        _matcher = pattern_comma.matcher(element);
        element = _matcher.replaceAll(COMMA_2);
        //「|」->「\|」
        _matcher = pattern_vline.matcher(element);
        element = _matcher.replaceAll(VLINE_2);
        //「?」->「\?」
        _matcher = pattern_qmark.matcher(element);
        element = _matcher.replaceAll(QMARK_2);
        //「*」->「\*」
        _matcher = pattern_asterisk.matcher(element);
        element = _matcher.replaceAll(ASTERISK_2);
        //2005.10.17 ADD END

        return element;
    }

    /**
     * @param element 入力文字列
     * @return 出力文字列
     */
    protected abstract String tranCharXML(String element);

    /**
     * @param element 入力文字列
     * @param elmName 要素名
     * @return 出力文字列
     */
    protected abstract String tranCharXMLContent(String element, String elmName);

    /**
     * @param element 入力文字列
     * @return 出力文字列
     */
    protected abstract String restoreCharXML(String element);

    protected abstract String restoreCharXMLContent(String element, String elmName);

//    protected final boolean isMatch(String pattern,String str){
//        this.pattern = PatternCache.get(pattern);
//        _matcher = this.pattern.matcher(str);
//        return _matcher.matches();
//    }

    protected final boolean isMatch(Pattern pattern,String str){
        _matcher = pattern.matcher(str);
        return _matcher.matches();
    }

    protected final Parser create(Parser pif) {
        if (pif instanceof ParserImpl) {
            pif = ParserImpl.getParser();
        } else if (pif instanceof jp.kuro.meteor.core.xhtml.ParserImpl) {
            pif = jp.kuro.meteor.core.xhtml.ParserImpl.getParser();
        } else if (pif instanceof jp.kuro.meteor.core.xml.ParserImpl) {
            pif = jp.kuro.meteor.core.xml.ParserImpl.getParser();
        }

        return pif;
    }
}